<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Single-PNG Boss Clicker (Hit FX + Upper Body Recoil)</title>
  <style>
    html, body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:#0f0f12; color:#e9e9ef; display:grid; place-items:center; }
    .wrap{ width:min(860px,94vw); padding:14px 12px 18px; text-align:center; }
    .hud{ display:grid; gap:10px; margin-bottom:10px; }
    .row{ display:flex; justify-content:center; flex-wrap:wrap; gap:12px; font-size:13px; color:rgba(233,233,239,.85); }
    .bar{ height:14px; background:rgba(255,255,255,.12); border-radius:999px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.45); }
    .bar>div{ height:100%; width:100%; background:rgba(255,255,255,.78); transform-origin:left center; transition:transform 120ms linear; }
    canvas{ width:100%; height:auto; background:radial-gradient(ellipse at center, rgba(255,255,255,.06), rgba(255,255,255,0) 60%); border-radius:18px; box-shadow:0 20px 60px rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.08); cursor:pointer; user-select:none; touch-action:manipulation; display:block; }
    .hint{ margin-top:10px; font-size:13px; color:rgba(233,233,239,.75); line-height:1.35; }
    button{ border:0; background:rgba(255,255,255,.12); color:#e9e9ef; padding:10px 14px; border-radius:14px; cursor:pointer; }
    button:hover{ background:rgba(255,255,255,.16); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="row">
        <div><b>HP:</b> <span id="hpText">—</span></div>
        <div><b>Урон/клик:</b> 8–20</div>
        <div><b>Добавлено:</b> откат верхней части назад</div>
      </div>
      <div class="bar"><div id="hpBar"></div></div>
      <div class="row"><button id="resetBtn">Сброс</button></div>
    </div>

    <canvas id="c" width="860" height="640"></canvas>
    <div class="hint">
      Клик/Space/Enter — удар. Тут одна PNG, но при ударе верхняя часть тела слегка откатывается назад (rotate вокруг “талии”).<br/>
      Если хочешь точнее (чтобы не крутился хвост/крылья) — лучше дать 2 PNG слоя: <b>верх</b> и <b>низ</b>.
    </div>
  </div>

<script>
(() => {
  const IMG_URL = "./boss_single.png";

  const MAX_HP = 1_000_000;
  let hp = MAX_HP;

  const DMG_MIN = 8, DMG_MAX = 20;

  const HIT_MS   = 240;
  const SHAKE_MS = 120;
  const FLASH_MS = 120;
  const PUNCH_MS = 190;

  // Upper-body recoil params (tweakable)
  const CUT_Y_RATIO = 0.46;     // where to "split" image into top/bottom (0..1)
  const MAX_TILT = -0.22;       // radians, negative = lean back
  const MAX_BACK = 10;          // px translation back during tilt

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const hpText = document.getElementById("hpText");
  const hpBar  = document.getElementById("hpBar");
  const resetBtn = document.getElementById("resetBtn");

  function resizeCanvas() {
    const cssW = canvas.clientWidth;
    const cssH = Math.round(cssW * (640/860));
    canvas.style.height = cssH + "px";

    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function easeOutCubic(t){ t = clamp01(t); return 1 - Math.pow(1-t, 3); }
  function randInt(a,b){ return (Math.random()*(b-a+1)+a)|0; }

  function setHP(v){
    hp = Math.max(0, Math.min(MAX_HP, v));
    hpText.textContent = hp.toLocaleString("ru-RU") + " / " + MAX_HP.toLocaleString("ru-RU");
    hpBar.style.transform = `scaleX(${hp / MAX_HP})`;
  }

  const img = new Image();
  img.src = IMG_URL;

  let hitT0 = -1;

  const floats = [];
  function spawnFloat(text){
    floats.push({
      text,
      x: canvas.clientWidth/2 + randInt(-80, 80),
      y: canvas.clientHeight/2 + randInt(-30, 30),
      vy: -0.35,
      born: performance.now(),
      life: 950
    });
  }

  const sparks = [];
  function spawnSpark(x,y){
    sparks.push({ x, y, born: performance.now(), life: 260 });
  }

  function hit(){
    if(!img.complete) return;
    if(hp <= 0) return;

    const dmg = randInt(DMG_MIN, DMG_MAX);
    setHP(hp - dmg);

    hitT0 = performance.now();

    spawnFloat("-" + dmg);
    spawnSpark(canvas.clientWidth/2 + randInt(-40,40), canvas.clientHeight/2 + randInt(-50,40));
  }

  function drawBossSplit(dx, dy, drawW, drawH, recoil){
    // Source split in image space
    const cutY = Math.floor(img.height * CUT_Y_RATIO);

    // Bottom part (no rotation)
    const bottomSh = img.height - cutY;
    const bottomDh = Math.round(drawH * (bottomSh / img.height));
    const bottomDy = Math.round(dy + drawH * (cutY / img.height));

    ctx.drawImage(
      img,
      0, cutY, img.width, bottomSh,
      Math.round(dx), bottomDy, Math.round(drawW), bottomDh
    );

    // Top part (rotate around waist pivot)
    const topSh = cutY;
    const topDh = Math.round(drawH * (topSh / img.height));
    const topDx = Math.round(dx);
    const topDy = Math.round(dy);

    const pivotX = Math.round(dx + drawW/2);
    const pivotY = Math.round(dy + drawH * (cutY / img.height)); // waist line in dest space

    const angle = MAX_TILT * recoil;
    const back = MAX_BACK * recoil;

    ctx.save();
    ctx.translate(pivotX, pivotY);
    ctx.rotate(angle);
    ctx.translate(-pivotX, -pivotY);

    // small translation "back" (to the left) while leaning
    ctx.translate(-back, -back*0.35);

    ctx.drawImage(
      img,
      0, 0, img.width, topSh,
      topDx, topDy, Math.round(drawW), topDh
    );

    ctx.restore();
  }

  function draw(now){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    ctx.clearRect(0,0,w,h);

    const scaleFit = Math.min((w*0.62)/img.width, (h*0.78)/img.height);
    let scale = scaleFit;

    let drawW = img.width * scale;
    let drawH = img.height * scale;

    let dx = (w - drawW)/2;
    let dy = (h - drawH)/2 + 10;

    const t = (now - hitT0);
    const inHit = t >= 0 && t <= HIT_MS;

    // shake
    if(inHit && t <= SHAKE_MS){
      const k = (1 - t/SHAKE_MS);
      dx += (Math.random()*2-1) * 10 * k;
      dy += (Math.random()*2-1) * 6 * k;
    }

    // scale punch
    let recoil = 0; // 0..1
    if(inHit && t <= PUNCH_MS){
      const p = t / PUNCH_MS;
      const up = p < 0.45 ? easeOutCubic(p/0.45) : (1 - easeOutCubic((p-0.45)/0.55));
      const punch = lerp(1.00, 1.045, up);
      scale *= punch;

      recoil = up; // same envelope for recoil

      drawW = img.width * scale;
      drawH = img.height * scale;
      dx = (w - drawW)/2;
      dy = (h - drawH)/2 + 10;
    }

    // draw boss (split top/bottom, tilt top on recoil)
    ctx.imageSmoothingEnabled = true;
    drawBossSplit(dx, dy, drawW, drawH, recoil);

    // flash overlay
    if(inHit && t <= FLASH_MS){
      const a = (1 - t/FLASH_MS) * 0.35;
      ctx.globalAlpha = a;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,w,h);
      ctx.globalAlpha = 1;
    }

    // sparks
    for(let i=sparks.length-1;i>=0;i--){
      const s = sparks[i];
      const age = now - s.born;
      if(age > s.life){ sparks.splice(i,1); continue; }
      const p = age / s.life;
      const alpha = 1 - p;

      const cx = s.x, cy = s.y;
      const r = 28 * (0.6 + 0.6*p);

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(cx, cy);
      ctx.rotate(p * 2.2);

      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      for(let k=0;k<8;k++){
        const ang = (Math.PI*2) * (k/8);
        ctx.moveTo(Math.cos(ang)*r*0.25, Math.sin(ang)*r*0.25);
        ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
      }
      ctx.stroke();

      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(0,0, 6*(1-p), 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // floating damage
    ctx.textAlign = "center";
    ctx.font = "700 22px system-ui";
    for(let i=floats.length-1;i>=0;i--){
      const f = floats[i];
      const age = now - f.born;
      if(age > f.life){ floats.splice(i,1); continue; }
      const p = age / f.life;
      const y = f.y + f.vy*age;
      ctx.globalAlpha = 1 - p;
      ctx.fillStyle = "#fff";
      ctx.fillText(f.text, f.x, y);
      ctx.globalAlpha = 1;
    }
    ctx.textAlign = "left";

    if(hp <= 0){
      ctx.fillStyle = "rgba(0,0,0,.45)";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = "800 28px system-ui";
      ctx.fillText("ПОБЕДА!", w/2, 80);
      ctx.font = "14px system-ui";
      ctx.fillStyle = "rgba(255,255,255,.80)";
      ctx.fillText("Нажми «Сброс», чтобы начать заново.", w/2, 106);
      ctx.textAlign = "left";
    }
  }

  function loop(now){
    if(img.complete) draw(now);
    requestAnimationFrame(loop);
  }

  canvas.addEventListener("click", hit);
  window.addEventListener("keydown", (e) => {
    if(e.code === "Space" || e.code === "Enter"){
      e.preventDefault();
      hit();
    }
  });

  resetBtn.addEventListener("click", () => {
    setHP(MAX_HP);
    hitT0 = -1;
    floats.length = 0;
    sparks.length = 0;
  });

  img.onload = () => {
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    setHP(MAX_HP);
    requestAnimationFrame(loop);
  };
})();
</script>
</body>
</html>
